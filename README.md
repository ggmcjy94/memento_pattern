# memento_pattern
메멘토 패턴

**1.개요**
 
 - 메멘토 패턴은 객체의 상태 정보를 가지는 클래스를 따로 생성하여 객체의 상태를 저장하거나 이전 상태로 복원할 수 있게 해주는 패턴이다.
 - 메멘토 패턴은 바둑, 오목, 체스 등의 보드게임 등에서 무르기 기능을 구현할 때 사용되기도 한다.
 - 이전 상태의 객체를 저장하기 위한 Originatorr가 클 경우 많은 메모리가 필요하다.
 
**2.사용시점**
 
 - 프로그래밍을 하다보면 객체의 내부 상태를 기록해둬야 할 때가 있다. 이러한 상황에는 오류에서 복구할 수 있도록 하거나 텍스트 편집기에서 실행 취소 기능을 구현할 때 필요하다.
이러한 상왕에서 객체의 상태를 기록해줘야 하는데 이를 외부에 저장하거나 다른 객체에서 접근 가능하도록 하면 캡슐화를 위반하게 된다. 
즉 상태를 저장할 클래스의 모든 내부 정보를 노출 하지 않고 이러한 상태에 접근하는 것을 제한해줘야 하는데 이럴 때 메멘토 패턴을 사용할 수 있다.


**3.장단점**

 **#장점**
 
  - 캡슐화를 위반하지 않고 객체의 state 스냅샷을 생성할 수 있다.
  - Caretaker가 Originator의 State 기록을 유지하므로 Originator의 코드가 단순화된다.
  
 **#단점**
 
  - 클라이언트가 Memento 객체를 너무 많이 생성하면 메모리가 많이 사용된다.
  - Caretaker는 오래된 memento 객체를 삭제 할 수 있도록 Originator의 생명 주기를 추적해야 한다.즉 자원을 소비해야 한다.
  - 몇몇 언어에서는 Originator만 Memento 객체에 접근할 수 있도록 만드는 것이 어려울 수 있다.
  
**4.사용라이브러리**

 - 자바: 객체 직렬화, java.io.Serializable, java.util.Date
 
**5.구분 객체**
 
 **#Originator**
 
  - 자체적으로 현재의 state를 저장하는 Memento 객체를 생성할 수 있다.
  - State를 복원하기 위해 Memento를 사용한다.
  
 **#Memento**
 
  - Originator의 state에 대한 스냅샷 역활을 하는 객체이다.
  - Originator 이외 객체의 접근으로부터 보호한다.
  - Memento를 immutable하게 만들고 생성자를 통해 데이터를 한 번만 전달한다.
 
 **CareTaker**
 
  - Memento 객체들을 저장하여 Originator의 동작을 추적한다.
  - Memento의 내용을 조작하거나 검토하지 않는다.
